import math
import numpy
import itertools

# Based on http://www.cim.mcgill.ca/~stephane/cs507/Project.html

epsilon = 1e-7

def _squared_points_distance(p1, p2):
    x1, y1 = p1
    x2, y2 = p2

    dx = x2 - x1
    dy = y2 - y1

    return dx * dx + dy * dy

def _calc_pass(l1, p, distance):
    """Calculate distance along l1 where p is closer than distance."""

    dx = l1[1][0] - l1[0][0]
    dy = l1[1][1] - l1[0][1]

    length_sq = dx * dx + dy * dy

    vx = p[0] - l1[0][0]
    vy = p[1] - l1[0][1]

    a = vx * dx + vy * dy

    D = a * a - length_sq * ((vx * vx + vy * vy) - distance * distance)
    if D < -epsilon:
        return (1, -1)

    if D < 0:
        sqrtD = 0
    else:
        sqrtD = math.sqrt(D)

    return (max((a - sqrtD) / length_sq , 0), min((a + sqrtD) / length_sq, 1))

def _decision(pl1, pl2, b, l, distance):
    """Decides if polylines pl1 and pl2 have Frechet distance lower or equal to distance.

    This is the internal version that actually does the work.
    Requires that the start and end points are close enough, but doesn't check this. """

    # Numbers of line segments
    n = len(pl1) - 1
    m = len(pl2) - 1

    assert b.shape == (2, m + 1)
        # Lowest x coordinate to get into the field i % 2, j from the bottom
        # Value 2 marks that the edge is not passable

    assert l.shape == (2, m + 1)
        # Lowest y coordinate to get into the field i % 2, j from the left
        # Value 2 marks that the edge is not passable

    for j in range(1, m + 1):
        l[0, j] = 2 # leftmost column is not accessible from the left ...
    l[0, 0] = 0 # ... except for the cell 0, 0.

    # bottommost row is not accessible from the bottom
    b[0, 0] = 2
    b[1, 0] = 2

    for (i, l1) in enumerate(zip(pl1[:-1], pl1[1:])):
        i = i % 2
        ii = 1 - i

        for (j, l2) in enumerate(zip(pl2[:-1], pl2[1:])):
            #print("l[{i}, {j}] = {l}; b[{i}, {j}] = {b}".format(i = i, j = j, l = l[i, j], b = b[i, j]))
            jj = j + 1

            pass_r = _calc_pass(l2, l1[1], distance)
            if b[i, j] <= 1:
                # if the current block could be accessed from the bottom, it can be exited
                # on the right anywhere
                l[ii, j] = pass_r[0]
            else:
                # if it could be accessed only from the left, then find the bottommost
                # possible right exit point
                l[ii, j] = max(pass_r[0], l[i, j])
            if l[ii, j] > pass_r[1] + epsilon:
                # if the best exit point we could find is outside of the passable interval,
                # mark the edge as impassable
                l[ii, j] = 2

            pass_t = _calc_pass(l1, l2[1], distance)
            if l[i, j] <= 1:
                # if the current block could be accessed from the left, it can be exited
                # on the top anywhere, and we do nothing
                b[i, jj] = pass_t[0]
            else:
                # if it could be accessed only from the bottom, then find the leftmost
                # possible top exit point
                b[i, jj] = max(pass_t[0], b[i, j])
            if b[i, jj] > pass_t[1] + epsilon:
                # if the best exit point we could find is outside of the passable interval,
                # mark the edge as impassable
                b[i, jj] = 2

    return b[(n - 1) % 2, m - 1] <= 1 or l[(n - 1) % 2, (m - 1)] <= 1

def _critical_distances_half(pl1, pl2, out, offset):
    for l in zip(pl1[:-1], pl1[1:]):
        for i, p in enumerate(pl2[1:-1]):
            dx = l[1][0] - l[0][0]
            dy = l[1][1] - l[0][1]
            length = math.hypot(dx, dy)

            # The simple case: Distance between each segment of pl1 and each point of pl2
            # This is the distance at which a new passage between two neighbor cells opens
            out[offset] = abs(dy * p[0] - dx * p[1] - l[0][0] * l[1][1] + l[1][0] * l[0][1]) / length
            offset += 1

            for q in pl2[2 + i:-1]:
                # The complicated case.
                # We are looking for places where a new passage opens, but no on neighboring cells
                # There is total O(M**2 * N + M * N**2) of these, so this is likely going to be
                # the performance bottleneck (although asymptotically sorting of these is worse)
                #
                # Geometrically, this is the smalles distance at which intersection of line l with discs centered at p and q with radius
                # `distance` have nonempty intersection.
                # Theoretically we would want to find intersections only with line segment l,
                # but IMO for intersections outside of the line segment this will just generate
                # an extra cricical value and the correct distance will be generated by one of the endpoints.

                vpx = l[0][0] - p[0]
                vpy = l[0][1] - p[1]
                vqx = l[0][0] - q[0]
                vqy = l[0][1] - q[1]

                denominator = ((q[0] - p[0]) * dx + (q[1] - p[1]) * dy)

                if denominator != 0:
                    t = 0.5 * (vqx * vqx + vqy * vqy - vpx * vpx - vpy * vpy) / denominator
                    out[offset] = math.hypot(vpx + t * dx, vpy + t * dy)
                    offset += 1
    return offset


def _critical_distances(pl1, pl2, out):
    """ Return candidate values of distance for the actual Frechet distance"""

    out[0] = math.sqrt(_squared_points_distance(pl1[0], pl2[0]))
    out[1] = math.sqrt(_squared_points_distance(pl1[-1], pl2[-1]))
    offset = _critical_distances_half(pl1, pl2, out, 2)
    offset = _critical_distances_half(pl2, pl1, out, offset)
    return offset

def frechet_distance_decision(pl1, pl2, distance):
    """Decides if polylines pl1 and pl2 have Frechet distance lower or equal to distance."""

    if _squared_points_distance(pl1[0], pl2[0]) > distance * distance:
        return False
    if _squared_points_distance(pl1[-1], pl2[-1]) > distance * distance:
        return False

    if len(pl1) < len(pl2):
        pl1, pl2 = pl2, pl1
    pl1 = numpy.asanyarray(pl1, dtype=numpy.double)
    pl2 = numpy.asanyarray(pl2, dtype=numpy.double)
    b = numpy.empty((2, len(pl2)))
    l = numpy.empty((2, len(pl2)))

    return _decision(pl1, pl2, b, l, distance)

def frechet_distance(pl1, pl2):
    if len(pl1) < len(pl2):
        pl1, pl2 = pl2, pl1
    pl1 = numpy.asanyarray(pl1, dtype=numpy.double)
    pl2 = numpy.asanyarray(pl2, dtype=numpy.double)
    b = numpy.empty((2, len(pl2)))
    l = numpy.empty((2, len(pl2)))

    distances = numpy.empty(2 + (len(pl1) - 1) * (len(pl2) - 1) * ((len(pl1) - 2) + (len(pl2) - 2)) // 2,
                            dtype=numpy.double)
    distances_count = _critical_distances(pl1, pl2, distances)
    distances.resize(distances_count, refcheck=False)
    distances.sort()

    assert _decision(pl1, pl2, b, l, distances[-1])

    low = 0
    high = len(distances) - 1
    while high > low + 1:
        current = (low + high) // 2
        if _decision(pl1, pl2, b, l, distances[current]):
            high = current
        else:
            low = current

    return distances[high]
